<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Easy Helicopter — Dodge</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  html,body{margin:0;background:#0b1220;color:#e6f1ff;font-family:Arial}
  .wrap{display:flex;flex-direction:column;align-items:center;margin-top:10px}
  canvas{background:#012;color:#fff;border:4px solid #094;image-rendering:pixelated}
  button{margin:10px;padding:6px 12px;border-radius:6px;background:#094;color:#fff;border:0;cursor:pointer}
</style>
</head>
<body>
<div class="wrap">
<h2>Easy Helicopter</h2>
<canvas id="game" width="800" height="450"></canvas>
<button id="restart">Restart</button>
</div>

<script>
(() => {
const c = document.getElementById("game");
const ctx = c.getContext("2d");
const W = c.width, H = c.height;

// --- EASY SETTINGS ---
let gravity = 0.25;       // ▼ softer fall
let lift = -6;            // ▲ smoother upward lift
let forwardSpeed = 2;     // slower forward
let spawnInterval = 1900; // obstacles spawn slower
let gapSize = 240;        // MUCH larger gap
let difficultyRamp = 0.00004; // very slow increase

// Helicopter
let heli = { x:120, y:H/2, vy:0, w:40, h:18, alive:true };

// Obstacles
let obs = [];
let score = 0;
let lastSpawn = 0;

let pressed = false;

document.addEventListener("mousedown", () => pressed = true);
document.addEventListener("mouseup", () => pressed = false);
document.addEventListener("touchstart", e => {e.preventDefault(); pressed = true});
document.addEventListener("touchend", e => {e.preventDefault(); pressed = false});
document.addEventListener("keydown", e => { if(e.code==="Space") pressed = true; });
document.addEventListener("keyup", e => { if(e.code==="Space") pressed = false; });

// Restart
document.getElementById("restart").onclick = reset;

// Reset game
function reset(){
  heli = { x:120, y:H/2, vy:0, w:40, h:18, alive:true };
  obs = [];
  score = 0;
  forwardSpeed = 2;
  spawnInterval = 1900;
  lastSpawn = performance.now();
}

function spawn(now){
  let gapY = Math.random()*(H-gapSize-80)+40;
  obs.push({ x:W+40, gapY });
  lastSpawn = now;
}

function collision(o){
  let hx = heli.x, hy = heli.y, hw = heli.w, hh = heli.h;
  if (hx + hw/2 < o.x || hx - hw/2 > o.x+50) return false;

  if (hy - hh/2 < o.gapY) return true;
  if (hy + hh/2 > o.gapY + gapSize) return true;

  return false;
}

function drawHeli(){
  ctx.fillStyle = "#ffe066";
  ctx.fillRect(heli.x-heli.w/2, heli.y-heli.h/2, heli.w, heli.h);
  ctx.fillStyle="#aaa";
  ctx.fillRect(heli.x-20, heli.y-15, 40, 4); // rotor
}

let last = performance.now();
function loop(now){
  let dt = now-last;
  last=now;

  ctx.fillStyle="#012"; 
  ctx.fillRect(0,0,W,H);

  if (heli.alive){
    // softer physics
    if (pressed) heli.vy += lift*0.05;
    else heli.vy += gravity;

    heli.vy = Math.max(-4, Math.min(4, heli.vy)); // clamp speed
    heli.y += heli.vy;

    // boundaries
    if (heli.y < 10 || heli.y > H-10) heli.alive=false;

    // difficulty grows slowly
    forwardSpeed += difficultyRamp*dt;
    spawnInterval = Math.max(1200, spawnInterval - difficultyRamp*1000*dt);

    // spawn obstacles
    if (now-lastSpawn > spawnInterval) spawn(now);

    // move obstacles
    for (let o of obs){
      o.x -= forwardSpeed;
      if (collision(o)) heli.alive=false;
      if (o.x+50 < heli.x && !o.passed){ o.passed = true; score++; }
    }

    // clean old
    obs = obs.filter(o => o.x > -80);
  }

  // draw obstacles
  ctx.fillStyle="#0f6";
  for (let o of obs){
    ctx.fillRect(o.x, 0, 50, o.gapY);
    ctx.fillRect(o.x, o.gapY+gapSize, 50, H-(o.gapY+gapSize));
  }

  drawHeli();

  ctx.fillStyle="#fff";
  ctx.font="20px Arial";
  ctx.fillText("Score: " + score, 20, 30);

  if (!heli.alive){
    ctx.font="40px Arial";
    ctx.fillStyle="red";
    ctx.fillText("CRASHED!", W/2-120, H/2);
  }

  requestAnimationFrame(loop);
}

reset();
loop(performance.now());
})();
</script>
</body>
</html>
